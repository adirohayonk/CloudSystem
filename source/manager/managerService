#!/usr/bin/python

import sys
sys.path.append('../lib/')
import socket
import threading
import socketLib as sockTools
import discover
import system
import databaseLib
import operator
import traceback
import os

class managerService(object):
	"""
	 class: managerService

	 this class is a service for the manager server.
	 this service should run in the background, unless debugging output is needed.
	 
	   -parameters: host, port::
		 -host - the host that socket should listen on.
		 -port - port for the socket.
		 
	 this class will create the socket and store it on mySocket variable.
	 
	 after running the class user should call listen function for server to start listening.
	 """
	def __init__(self, host, port):
		self.host = host
		self.port = port
		self.mySocket = sockTools.create_and_bind_socket(self.host, self.port)
		self.db = databaseLib.DbController(system.getSystemIp()) #get controller for the db
		self.currentJobID = self.db.get_next_jobid()
		system.createEnv() #create environment folders
		#workersInformation = discover.discoverWorkers(3) #get workers information 
		#discover.updateWorkersInDb(self.db,workersInformation)
		self.workersList = self.db.get_workers_list() #store workers list for local use
		self.numberOfWorkers = len(self.workersList)

	def listen(self):
		"""
		This function is waiting for incoming connections.
		when a connection arrive to the server socket.
		socket is assigned to this connection and a new thread is created
		so connections could occurs simultaniously.
		then the thread calls listen_to_client function.
		
		"""
		self.mySocket.listen(5)
		print("Server Started")
		while True:
			client_socket, address = self.mySocket.accept() #accept on incoming connetion
			threading.Thread(target=self.listen_to_client, args=(client_socket, address)).start() # creating new thread for the connection 

	def listen_to_client(self, client_socket, address):
		"""
		this functions listen to client waiting to receive new information and act accordingly.
		- parameters: client_socket, address::
		 -client_socket - the socket that transfers the client data.
		 -address - client address for filenames and debugging.
		 
		 client/workersi can sends several words through socket for various functions:
		 **sendFile** - when this word is received the manager start receiving the job file.
		 **newWorker** -  when this word is received the manager calls the udpPacket methods and worker will send the discover packet.
		 **receiveResults** - when this word is received the manager sends the results file to the client.
		"""
		action = True
		while action:
			try:
				data_from_client = sockTools.recv_and_decode(client_socket) #recv message from client
				if data_from_client == "":
					print("{} Disconnected".format(address))
					client_socket.close()
					return False
				if data_from_client == "sendFile":
					self.receive_file_from_client(client_socket, address)
				if data_from_client == "newWorker":
					self.add_new_worker(client_socket, address)
				if data_from_client == "receiveResults":
					self.receive_results(client_socket)
				action = False
			except socket.error:
				print("{} Disconnected".format(address))
				print(traceback.format_exc())
				client_socket.close()
				return False

	def receive_file_from_client(self, client_socket, address):
		"""
		this functions receives files from the client/worker by sending the phrase and then start receiving process by calling receive_file method from sockTools library.
		- parameters: client_socket, address::
		 -client_socket - the socket that transfers the client data.
		 -address - client address for filenames and debugging.
		 """
		sockTools.send_and_encode(client_socket, str(self.currentJobID))
		fileName = sockTools.receiveFile(client_socket) #receive the file from client 
		nextFreeWorker = self.evaluteWorkers() #find the worker with least jobs
		newFileName = str(self.currentJobID) + "." + fileName
		os.rename("jobs/" + fileName, "jobs/" + newFileName) 
		self.writeJobToDB(newFileName, nextFreeWorker)	
		self.send_file_to_worker(nextFreeWorker, newFileName)

	def writeJobToDB(self, filename, hostname):
		jobData = [self.currentJobID, filename, hostname, "ACCEPTED"] 
		self.db.insert_to_db("jobs", jobData) 
		self.currentJobID += 1

	def send_file_to_worker(self, workerHostname, filename):
		workerIP = (self.db.get_host_data(workerHostname, "ipaddr"))[0] 
		print("\nSelected {} ,worker ip is: {}".format(workerHostname, workerIP))
		print("Sending job file to {}".format(workerHostname))
		worker_socket = sockTools.create_socket(isTCP = True) 
		worker_socket.connect((workerIP, 4444))
		sockTools.send_and_encode(worker_socket,"sendFile")	
		response = sockTools.recv_and_decode(worker_socket)
		sockTools.sendFile(worker_socket, filename) #send the file to worker

	def add_new_worker(self, client_socket, address):
		"""
		this function add new worker to the system and to the database.
		- parameters: client_socket::
		 -client_socket - the socket that transfers the client data. 
		"""
		newWorkerInformation = sockTools.recv_and_decode(client_socket)
		workerInformationList = newWorkerInformation.split(":")
		dbResult = self.db.get_host_data_by_ip(address[0])	
		if dbResult:
			sockTools.send_and_encode(client_socket,"{} is already a worker".format(address[0]))
		else:
			self.db.insert_to_db('hosts', workerInformationList)
			sockTools.send_and_encode(client_socket,"new worker has been added info is:{}".format(workerInformationList))
			self.numberOfWorkers += 1
		

	def receive_results(self, client_socket):
		sockTools.send_and_encode(client_socket, "please provide job ID")
		requestedJobID = sockTools.recv_and_decode(client_socket)
		worker_socket = sockTools.create_socket(isTCP = True) 
		workerHostname = (self.db.get_job_data(requestedJobID,"hostname"))[0]	
		workerIP = (self.db.get_host_data(workerHostname, "ipaddr"))[0] 
		worker_socket.connect((workerIP, 4444))
		sockTools.send_and_encode(worker_socket, "receiveFile")
		response = sockTools.recv_and_decode(worker_socket)
		if response[:5] == "going":
			sockTools.send_and_encode(worker_socket, requestedJobID)
		resultsFile = sockTools.receiveFile(worker_socket)
		sockTools.send_and_encode(client_socket, "Are you ready to download the results file(y/n)")
		response = sockTools.recv_and_decode(client_socket)
		print("Going to send {} to client".format(resultsFile))
		if response[:1] == "y":
			sockTools.sendFile(client_socket, resultsFile)
		

		
	def evaluteWorkers(self):
		""" this method finds the worker with least jobs and returns his hostname
		
		Returns:
			String -- most available worker 
		"""
		workersJobsNum = dict() #workers jobs number will by stored in dictionary
		print("Number of jobs for each worker:")
		for worker in self.workersList:
			workerJobsInProg = self.db.get_worker_jobs(worker, 'IN-PROGRESS') #get only IN-PROGRESS jobs from db
			workersJobsNum[worker] = len(workerJobsInProg) #store number of jobs
			print("{} - {}".format(worker,workersJobsNum[worker]),end=",")
		workersJobsNum = sorted(workersJobsNum.items(), key = lambda kv: kv[1])# sort workers by number of jobs
		nextFreeWorker = workersJobsNum[0][0] # store the worker with least jobs
		return nextFreeWorker


if __name__ == "__main__":
	port_num = 4444
	managerService('0.0.0.0', port_num).listen()
