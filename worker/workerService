#!/usr/bin/python

import sys
sys.path.append('../lib/')
import socket
import threading
import socketLib as sockTools
import discover
import databaseLib
import system

class workerService(object):
	"""
	class: workerService
	this class is a service for the worker server.
	this service should run in the background, unless debugging output is needed.
	
	   -parameters: host, port::
		 -host - the host that socket should listen on.
		 -port - port for the socket.
		 
	 this class will create the socket and store it on mySocket variable.
	 
	 after running the class user should call listen function for server to start listening.
	 """
	def __init__(self, host, port):
		self.host = host
		self.port = port
		self.mySocket = sockTools.create_and_bind_socket(self.host, self.port)
		system.createEnv()
		# maybe improve this method to better performance
		#self.managerAddress = discover.receiveDiscoverPacket()
		# maybee improve this method to better performance
		self.managerAddress = "192.168.1.17" 
		self.db = databaseLib.DbController(self.managerAddress)

	def listen(self):
		"""
		This function is waiting for incoming connections.
		when a connection arrive to the server socket.
		socket is assigned to this connection and a new thread is created
		so connections could occurs simultaniously.
		then the thread calls listen_to_server function.    
		"""
		self.mySocket.listen(5)
		print("Worker service started")
		while True:
			try:
				server_socket, address = self.mySocket.accept()
				threading.Thread(target=self.listen_to_server, args=(server_socket, address)).start()
			except socket.timeout:
				print("Timeout reached, waiting for a connection again")

	def listen_to_server(self, server_socket, address):
		"""
		this functions listen to server waiting to receive new information and act accordingly.
		- parameters: server_socket, address::
		 -server_socket - the socket that transfers the server data.
		 -address - server address for filenames and debugging.
		 
		 server can send several words through socket for various functions:
		 **sendFile** - when this word is received the worker start receiving the job file.
		"""
		while True:
			try:
				data_from_server = sockTools.recv_and_decode(server_socket)
				print(data_from_server)
				if data_from_server == "":
					print("{} Disconnected".format(address))
					server_socket.close()
					return False
				if data_from_server == "sendFile":
					self.receive_file_from_server(server_socket, address)
				if data_from_server == "receiveFile":
					self.send_requested_file(server_socket)
			except socket.error:
				print("{} Disconnected".format(address))
				server_socket.close()
				return False

	def receive_file_from_server(self, server_socket, address):
		"""
		this functions receives files from the server by sending the phrase and then start receiving process by calling receive_file method from sockTools library stores fileName and then execute the job.
		- parameters:server_socket, address::
		 -server_socket - the socket that transfers the server data.
		 -address - server address for filenames and debugging.
		 """
		fileName = sockTools.receiveFile(server_socket)
		outputFileName = system.run_file(fileName, self.db)

	def send_requested_file(self, server_socket):
		sockTools.send_and_encode(server_socket, "going to send Results file")
		requestedJobID = sockTools.recv_and_decode(server_socket)
		requestedFileName = (self.db.get_job_data(requestedJobID, "fileName"))[0]
		filename = "results-" + requestedFileName
		sockTools.sendFile(server_socket, filename)
		server_socket.close()
		

if __name__ == "__main__":
	port_num = 4444
	workerService('0.0.0.0', port_num).listen()
